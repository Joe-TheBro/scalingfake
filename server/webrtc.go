package main

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	"io"
	"math/rand"
	"net"
	"os/exec"
	"sort"
	"sync"
	"time"

	"github.com/charmbracelet/log"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/rtp"
	"github.com/pion/webrtc/v4"
	"gocv.io/x/gocv"
	"golang.org/x/crypto/ssh"
)

type bufferedPacket struct {
	packet  *rtp.Packet
	arrival time.Time
}

// JitterBuffer buffers RTP packets for a fixed delay to allow reordering.
type JitterBuffer struct {
	inputChan  chan *rtp.Packet
	outputChan chan *rtp.Packet
	maxDelay   time.Duration

	mu     sync.Mutex
	buffer []bufferedPacket
}

// global map and mutex for handling tracking connections
var (
	connPCMap = make(map[string]*webrtc.PeerConnection)
	connPCMapMu sync.Mutex
)

func CreatePeerConnection() (*webrtc.PeerConnection, error) {
	mediaEngine := &webrtc.MediaEngine{}

	webrtcConfig := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}

	

	if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType:     "video/jpeg",
			ClockRate:    90000,		
		},
		PayloadType: 97,
	},
		webrtc.RTPCodecTypeVideo); err != nil {
		log.Error("Failed to register jpeg codec:", err)
		return nil, err
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	intercepterRegistry := &interceptor.Registry{}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		log.Error("Failed to create intervalpli interceptor:", err)
		return nil, err
	}
	intercepterRegistry.Add(intervalPliFactory)

	if err = webrtc.RegisterDefaultInterceptors(mediaEngine, intercepterRegistry); err != nil {
		log.Error("Failed to register default interceptors:", err)
		return nil, err
	}

	api := webrtc.NewAPI(webrtc.WithMediaEngine(mediaEngine), webrtc.WithInterceptorRegistry(intercepterRegistry))
	return api.NewPeerConnection(webrtcConfig)
}

func StartSshSignalingServer(privateBytes []byte) {
	privateKey, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		log.Fatal("Error parsing private key:", err)
	}

	sshConfig := &ssh.ServerConfig{
		NoClientAuth: false,
		PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
			return nil, nil
		},
	}

	sshConfig.AddHostKey(privateKey)

	// Listen for incoming connections
	listener, err := net.Listen("tcp", "0.0.0.0:2222")
	if err != nil {
		log.Fatal("Error listening on port 2222:", err)
	}
	log.Info("Signaling server listening on port 2222")

	for {
		tcpConn, err := listener.Accept()
		if err != nil {
			log.Warn("Error accepting connection:", err)
			continue
		}

		go handleSSHConnection(tcpConn, sshConfig)		
	}
}

func handleSSHConnection(conn net.Conn, sshConfig *ssh.ServerConfig) {
	sshConn, chans, reqs, err := ssh.NewServerConn(conn, sshConfig)
	if err != nil {
		log.Warn("SSH handshake failed:", err)
		conn.Close()
		return
	}
	defer sshConn.Close()

	// Create a new PeerConnection for this SSH connection.
	peerConnection, err := CreatePeerConnection()
	if err != nil {
		log.Error("Failed to create PeerConnection:", err)
		return
	}
	defer func() {
		if err := peerConnection.Close(); err != nil {
			log.Error("Failed to close PeerConnection:", err)
		}
	}()

	// Set the handler for ICE connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
		log.Printf("Connection State has changed %s \n", connectionState.String())
	})

	// incoming tracks
	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
		data := make(chan *rtp.Packet)
		go HandleIncomingTrack(track, data)
		go WriteToUDP(data)
	})

	// Add outgoing track
	track, err := webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{MimeType: "video/jpeg", ClockRate: 90000}, "video", "pion")
	if err != nil {
		log.Error("Failed to create outgoing track:", err)
		return
	}

	_, err = peerConnection.AddTrack(track)
	if err != nil {
		log.Error("Failed to add outgoing track:", err)
		return
	}

	// go WriteOutgoingTrack(peerConnection, track)
	go StreamMPEGTSToTrack(track)

	// Store the mapping using the remote address as a key.
	connKey := sshConn.RemoteAddr().String()
	connPCMapMu.Lock()
	connPCMap[connKey] = peerConnection
	connPCMapMu.Unlock()

	// Ensure cleanup on disconnect.
	defer func() {
		connPCMapMu.Lock()
		delete(connPCMap, connKey)
		connPCMapMu.Unlock()
		peerConnection.Close()
	}()

	log.Info("New SSH connection from", connKey)

	// Discard global requests.
	go ssh.DiscardRequests(reqs)

	// Handle channels for this SSH connection.
	for newChannel := range chans {
		if newChannel.ChannelType() != "session" {
			newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
			continue
		}

		channel, requests, err := newChannel.Accept()
		if err != nil {
			log.Warn("Error accepting channel:", err)
			continue
		}

		// Process requests for this channel.
		go func(in <-chan *ssh.Request) {
			for req := range in {
				if req.Type == "exec" {
					command, err := parseSSHExecCommand(req.Payload)
					if err != nil {
						log.Error("Failed to parse exec command:", err)
						req.Reply(false, nil)
						channel.Close()
						continue
					}

					log.Info("Received command:", command)

					if command == "webrtc-signal" {
						req.Reply(true, nil) // Acknowledge the request.
						// Use the per-connection PeerConnection for signaling.
						HandleWebRTCSignaling(channel, peerConnection)
					} else {
						req.Reply(false, nil)
						channel.Close()
					}
				} else {
					req.Reply(false, nil)
				}
			}
		}(requests)
	}
}

func HandleWebRTCSignaling(channel ssh.Channel, peerConnection *webrtc.PeerConnection) {
	defer channel.Close()

	// Create channel buffer
	buf := make([]byte, 4096)
	n, err := channel.Read(buf)
	if err != nil && err != io.EOF {
		log.Fatal("Error reading from signaling channel:", err)
		return
	}

	sdpOffer := string(buf[:n])
	log.Info("Received SDP offer:", sdpOffer)

	// Process the SDP offer and create an answer
	sdpAnswer := ProcessSDPOffer(sdpOffer, peerConnection)
	_, err = channel.Write([]byte(sdpAnswer))
	if err != nil {
		log.Fatal("Error writing SDP answer to channel:", err)
		return
	}	
		
	// Block indefinitely
	select {}
}


func parseSSHExecCommand(payload []byte) (string, error) {
	if len(payload) < 4 {
		return "", errors.New("payload too short")
	}

	// Create a reader over the payload.
	r := bytes.NewReader(payload)

	// Read the 4-byte length field.
	var length uint32
	if err := binary.Read(r, binary.BigEndian, &length); err != nil {
		return "", err
	}

	// Ensure there are enough bytes for the command.
	if uint32(len(payload))-4 < length {
		return "", errors.New("payload does not contain full command")
	}

	// Read the command string.
	cmdBytes := make([]byte, length)
	if _, err := io.ReadFull(r, cmdBytes); err != nil {
		return "", err
	}

	return string(cmdBytes), nil
}

func ProcessSDPOffer(sdpOffer string, peerConnection *webrtc.PeerConnection) string {
	// Set the remote description
	err := peerConnection.SetRemoteDescription(webrtc.SessionDescription{
		Type: webrtc.SDPTypeOffer,
		SDP:  sdpOffer,
	})

	if err != nil {
		log.Fatal("Error setting remote description:", err)
		return ""
	}

	// Create an answer
	answer, err := peerConnection.CreateAnswer(nil)
	if err != nil {
		log.Fatal("Error creating answer:", err)
		return ""
	}
	
	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	// Set the local description
	err = peerConnection.SetLocalDescription(answer)
	if err != nil {
		log.Fatal("Error setting local description:", err)
		return ""
	}

	// Block until ICE gathering has completed
	<-gatherComplete

	return answer.SDP
}

func StreamMPEGTSToTrack(track *webrtc.TrackLocalStaticRTP) {
	capture, err := gocv.OpenVideoCapture("udp://127.0.0.1:1234")
	if err != nil {
		log.Error("Error opening video capture:", err)
		return
	}
	defer capture.Close()

	fps := 60
	maxPayloadSize := 1200
	var sequenceNumber uint16 = 0
	var timestamp uint32 = 0
	ssrc := uint32(rand.Uint32())

	ticker := time.NewTicker(time.Second / time.Duration(fps))
	defer ticker.Stop()

	for range ticker.C {
		frame := gocv.NewMat()
		if ok := capture.Read(&frame); !ok || frame.Empty() {
			log.Error("Error reading frame from capture")
			frame.Close()
			continue
		}

		// Encode the frame to JPEG
		buf, err := gocv.IMEncode(".jpg", frame)
		frame.Close()
		if err != nil {
			log.Error("Error encoding frame to JPEG:", err)
			buf.Close()
			continue
		}

		jpegBytes := make([]byte, buf.Len())
		copy(jpegBytes, buf.GetBytes())
		buf.Close()

		packets := packetizeJPEG(jpegBytes, maxPayloadSize)
		for i, payload := range packets {
			marker := (i == len(packets)-1)
			rtpPacket := &rtp.Packet{
				Header: rtp.Header{
					Version:        2,
					PayloadType:   97, // Use a dynamic payload type (96-127) for JPEG
					SequenceNumber: sequenceNumber,
					Timestamp:      timestamp,
					SSRC:           ssrc,
					Marker: 	   marker,
				},
				Payload: payload,
			}
			sequenceNumber++
			if err := track.WriteRTP(rtpPacket); err != nil {
				log.Error("Error writing RTP packet:", err)
			}
		}
		timestamp += 90000 / uint32(fps)
	}
}

func packetizeJPEG(jpegData []byte, maxPayloadSize int) [][]byte {
    const jpegHeaderSize = 8
    var packets [][]byte
    dataLen := len(jpegData)
    offset := 0

    // Determine the header values. These may come from the JPEG's metadata or be set statically.
    typeSpecific := byte(0)
    jpegType := byte(1)     // Example value; choose the one that matches your use case.
    quality := byte(255)    // Maximum quality by default.
    width := byte(1280 / 8) // In 8-pixel units.
    height := byte(720 / 8)

    for offset < dataLen {
        // Reserve space for header.
        chunkSize := maxPayloadSize - jpegHeaderSize
        if offset+chunkSize > dataLen {
            chunkSize = dataLen - offset
        }

        // Create header.
        header := make([]byte, jpegHeaderSize)
        header[0] = typeSpecific
        // Fragment offset is 3 bytes; big endian.
        header[1] = byte((offset >> 16) & 0xFF)
        header[2] = byte((offset >> 8) & 0xFF)
        header[3] = byte(offset & 0xFF)
        header[4] = jpegType
        header[5] = quality
        header[6] = width
        header[7] = height

        // Combine header with the JPEG chunk.
        packet := make([]byte, jpegHeaderSize+chunkSize)
        copy(packet[:jpegHeaderSize], header)
        copy(packet[jpegHeaderSize:], jpegData[offset:offset+chunkSize])
        packets = append(packets, packet)

        offset += chunkSize
    }
    return packets
}

func isValidJPEG(data []byte) bool {
    if len(data) < 4 {
        return false
    }
    return data[0] == 0xFF && data[1] == 0xD8 &&
           data[len(data)-2] == 0xFF && data[len(data)-1] == 0xD9
}

// NewJitterBuffer creates a new jitter buffer with the given maximum delay.
func NewJitterBuffer(maxDelay time.Duration) *JitterBuffer {
	jb := &JitterBuffer{
		inputChan:  make(chan *rtp.Packet, 100),
		outputChan: make(chan *rtp.Packet, 100),
		maxDelay:   maxDelay,
		buffer:     []bufferedPacket{},
	}
	go jb.run()
	return jb
}

func (jb *JitterBuffer) run() {
	ticker := time.NewTicker(10 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case pkt := <-jb.inputChan:
			jb.mu.Lock()
			jb.buffer = append(jb.buffer, bufferedPacket{packet: pkt, arrival: time.Now()})
			jb.mu.Unlock()
		case <-ticker.C:
			now := time.Now()
			var ready []bufferedPacket
			jb.mu.Lock()
			var remaining []bufferedPacket
			for _, bp := range jb.buffer {
				if now.Sub(bp.arrival) >= jb.maxDelay {
					ready = append(ready, bp)
				} else {
					remaining = append(remaining, bp)
				}
			}
			jb.buffer = remaining
			jb.mu.Unlock()

			if len(ready) > 0 {
				// Sort the ready packets by sequence number.
				sort.Slice(ready, func(i, j int) bool {
					return ready[i].packet.SequenceNumber < ready[j].packet.SequenceNumber
				})
				for _, bp := range ready {
					jb.outputChan <- bp.packet
				}
			}
		}
	}
}

// Input returns the input channel to feed RTP packets into.
func (jb *JitterBuffer) Input() chan<- *rtp.Packet {
	return jb.inputChan
}

// Output returns the output channel from which sorted RTP packets can be read.
func (jb *JitterBuffer) Output() <-chan *rtp.Packet {
	return jb.outputChan
}


func HandleIncomingTrack(track *webrtc.TrackRemote, data chan *rtp.Packet) {
	// receive rtp packets, use gocv to write to camera feed
	for {
		packet, _, err := track.ReadRTP()
		if err != nil {
			log.Error("Error reading RTP packet:", err)
			break
		}

		// send rtp to channel
		data <- packet
	}
}

// func WriteToUDP(packets chan *rtp.Packet) {
//     ffmpegCmd := exec.Command("ffmpeg",
//         "-f", "image2pipe",
// 		"-vcodec", "mjpeg",
//         "-i", "pipe:0",
//         "-c:v", "mpeg2video",
// 		"-b:v", "30M",
// 		"-maxrate", "30M",
// 		"-bufsize", "60M",
//         "-preset", "ultrafast",
//         "-tune", "zerolatency",
//         "-f", "mpegts",
//         "udp://127.0.0.1:10000",
// 		// "output.ts",
//     )

//     ffmpegStdin, err := ffmpegCmd.StdinPipe()
//     if err != nil {
//         log.Fatalf("Error getting ffmpeg stdin pipe: %v", err)
//     }

//     ffmpegStderr, err := ffmpegCmd.StderrPipe()
//     if err != nil {
//         log.Fatalf("Error getting ffmpeg stderr pipe: %v", err)
//     }

//     go func() {
//         scanner := bufio.NewScanner(ffmpegStderr)
//         for scanner.Scan() {
//             log.Infof("ffmpeg: %s", scanner.Text())
//         }
//         if err := scanner.Err(); err != nil {
//             log.Errorf("Error reading ffmpeg stderr: %v", err)
//         }
//     }()

//     err = ffmpegCmd.Start()
//     if err != nil {
//         log.Fatalf("Error starting ffmpeg: %v", err)
//     }

// 	fragmentBuffer := make(map[int][]byte)
// 	expectedTotalSize := -1

// 	for packet := range packets {
// 		if len(packet.Payload) < 8 {
//         	log.Error("packet too small to extract JPEG header")
//         	continue
//     	}
//     	header := packet.Payload[:8]
//     	// Calculate fragment offset from header (big-endian)
//     	fragmentOffset := int(header[1])<<16 | int(header[2])<<8 | int(header[3])
//     	payload := packet.Payload[8:]
		
//     	fragmentBuffer[fragmentOffset] = payload
		
//     	if packet.Marker {
//     	    expectedTotalSize = fragmentOffset + len(payload)
//     	}
		
// 		// Try to reassemble if we know the total size
// 		if expectedTotalSize > 0 {
// 			complete := true
// 			frameData := make([]byte, expectedTotalSize)
// 			for offset := 0; offset < expectedTotalSize; {
// 				frag, exists := fragmentBuffer[offset]
// 				if !exists {
// 					complete = false
// 					break
// 				}
// 				copy(frameData[offset:], frag)
// 				offset += len(frag)
// 			}
// 			if complete {
// 				if !isValidJPEG(frameData) {
// 					log.Warn("Invalid JPEG frame")
// 				} else {
// 					if _, err := ffmpegStdin.Write(frameData); err != nil {
// 						log.Fatalf("Error writing to ffmpeg stdin: %v", err)
// 					}
// 				}
// 				// Reset for next frame
// 				fragmentBuffer = make(map[int][]byte)
// 				expectedTotalSize = -1
// 			}
// 		}
// 	}
// }

func WriteToUDP(packets chan *rtp.Packet) {
	ffmpegCmd := exec.Command("ffmpeg",
		"-f", "image2pipe",
		"-vcodec", "mjpeg",
		"-i", "pipe:0",
		"-c:v", "mpeg2video",
		"-b:v", "30M",
		"-maxrate", "30M",
		"-bufsize", "60M",
		"-preset", "ultrafast",
		"-tune", "zerolatency",
		"-f", "mpegts",
		"udp://127.0.0.1:10000",
	)

	ffmpegStdin, err := ffmpegCmd.StdinPipe()
	if err != nil {
		log.Fatalf("Error getting ffmpeg stdin pipe: %v", err)
	}

	ffmpegStderr, err := ffmpegCmd.StderrPipe()
	if err != nil {
		log.Fatalf("Error getting ffmpeg stderr pipe: %v", err)
	}

	go func() {
		scanner := bufio.NewScanner(ffmpegStderr)
		for scanner.Scan() {
			log.Infof("ffmpeg: %s", scanner.Text())
		}
		if err := scanner.Err(); err != nil {
			log.Errorf("Error reading ffmpeg stderr: %v", err)
		}
	}()

	err = ffmpegCmd.Start()
	if err != nil {
		log.Fatalf("Error starting ffmpeg: %v", err)
	}

	// Create a jitter buffer with a 50ms delay.
	jb := NewJitterBuffer(100 * time.Millisecond)
	go func() {
		for pkt := range packets {
			jb.Input() <- pkt
		}
	}()

	fragmentBuffer := make(map[int][]byte)
	expectedTotalSize := -1
	var lastPacketTime time.Time

	// Process packets from the jitter buffer.
	for packet := range jb.Output() {
		if len(packet.Payload) < 8 {
			log.Error("packet too small to extract JPEG header")
			continue
		}
		header := packet.Payload[:8]
		fragmentOffset := int(header[1])<<16 | int(header[2])<<8 | int(header[3])
		payload := packet.Payload[8:]

		if fragmentOffset == 0 && len(fragmentBuffer) > 0 {
			log.Warn("New frame detected. Flushing incomplete frame.")
			fragmentBuffer = make(map[int][]byte)
			expectedTotalSize = -1
		}

		fragmentBuffer[fragmentOffset] = payload

		if packet.Marker {
			expectedTotalSize = fragmentOffset + len(payload)
		}

		now := time.Now()
		if lastPacketTime.IsZero() {
			lastPacketTime = now
		} else if now.Sub(lastPacketTime) > 60*time.Millisecond {
			// Flush the buffer if we haven't completed the frame in 100ms.
			if expectedTotalSize > 0 {
				complete := true
				for offset := 0; offset < expectedTotalSize; {
					frag, exists := fragmentBuffer[offset]
					if !exists {
						complete = false
						break
					}
					offset += len(frag)
				}
			if !complete {
				log.Warn("Frame incomplete after timeout. Flushing buffer.")
				fragmentBuffer = make(map[int][]byte)
				expectedTotalSize = -1
			}
		}
		lastPacketTime = now
	}

		if expectedTotalSize > 0 {
			complete := true
			frameData := make([]byte, expectedTotalSize)
			offset := 0
			for offset < expectedTotalSize {
				frag, exists := fragmentBuffer[offset]
				if !exists {
					complete = false
					break
				}
				copy(frameData[offset:], frag)
				offset += len(frag)
			}
			if complete {
				if !isValidJPEG(frameData) {
					log.Warn("Invalid JPEG frame")
				} else {
					if _, err := ffmpegStdin.Write(frameData); err != nil {
						log.Fatalf("Error writing to ffmpeg stdin: %v", err)
					}
				}
				fragmentBuffer = make(map[int][]byte)
				expectedTotalSize = -1
				lastPacketTime = time.Time{}
			}
		}
	}
}