package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"io"
	"net"
	"sync"

	"github.com/bluenviron/gortsplib/v4"
	"github.com/bluenviron/gortsplib/v4/pkg/base"
	"github.com/bluenviron/gortsplib/v4/pkg/description"
	"github.com/bluenviron/gortsplib/v4/pkg/format"
	"github.com/charmbracelet/log"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/rtcp"
	"github.com/pion/rtp"
	"github.com/pion/webrtc/v4"
	"gocv.io/x/gocv"
	"golang.org/x/crypto/ssh"
)

// global map and mutex for handling tracking connections
var (
	connPCMap = make(map[string]*webrtc.PeerConnection)
	connPCMapMu sync.Mutex
)

func CreatePeerConnection() (*webrtc.PeerConnection, error) {
	mediaEngine := &webrtc.MediaEngine{}

	webrtcConfig := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}

	

	if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: "video/H264", ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
	},
		webrtc.RTPCodecTypeVideo); err != nil {
		log.Error("Failed to register H264 codec:", err)
		return nil, err
	}

	// if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
	// 	RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: "video/H264", ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
	// },
	// 	webrtc.RTPCodecTypeAudio); err != nil {
	// 	log.Error("Failed to register H264 codec:", err)
	// 	return nil, err
	// }

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	intercepterRegistry := &interceptor.Registry{}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		log.Error("Failed to create intervalpli interceptor:", err)
		return nil, err
	}
	intercepterRegistry.Add(intervalPliFactory)

	if err = webrtc.RegisterDefaultInterceptors(mediaEngine, intercepterRegistry); err != nil {
		log.Error("Failed to register default interceptors:", err)
		return nil, err
	}

	api := webrtc.NewAPI(webrtc.WithMediaEngine(mediaEngine), webrtc.WithInterceptorRegistry(intercepterRegistry))
	return api.NewPeerConnection(webrtcConfig)
}

func StartSshSignalingServer(privateBytes []byte) {
	privateKey, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		log.Fatal("Error parsing private key:", err)
	}

	sshConfig := &ssh.ServerConfig{
		NoClientAuth: false,
		PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
			return nil, nil
		},
	}

	sshConfig.AddHostKey(privateKey)

	// Listen for incoming connections
	listener, err := net.Listen("tcp", "0.0.0.0:2222")
	if err != nil {
		log.Fatal("Error listening on port 2222:", err)
	}
	log.Info("Signaling server listening on port 2222")

	for {
		tcpConn, err := listener.Accept()
		if err != nil {
			log.Warn("Error accepting connection:", err)
			continue
		}

		go handleSSHConnection(tcpConn, sshConfig)		
	}
}

func handleSSHConnection(conn net.Conn, sshConfig *ssh.ServerConfig) {
	sshConn, chans, reqs, err := ssh.NewServerConn(conn, sshConfig)
	if err != nil {
		log.Warn("SSH handshake failed:", err)
		conn.Close()
		return
	}
	defer sshConn.Close()

	// Create a new PeerConnection for this SSH connection.
	peerConnection, err := CreatePeerConnection()
	if err != nil {
		log.Error("Failed to create PeerConnection:", err)
		return
	}
	defer func() {
		if err := peerConnection.Close(); err != nil {
			log.Error("Failed to close PeerConnection:", err)
		}
	}()

	// Set the handler for ICE connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
		log.Printf("Connection State has changed %s \n", connectionState.String())
	})

	// incoming tracks
	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
		data := make(chan []byte)
		go HandleIncomingTrack(track, data)
		go WriteToCamera(data)
	})

	// Add outgoing track
	track, err := webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeH264}, "video", "pion")
	if err != nil {
		log.Error("Failed to create outgoing track:", err)
		return
	}
	go WriteOutgoingTrack(peerConnection, track)

	// Store the mapping using the remote address as a key.
	connKey := sshConn.RemoteAddr().String()
	connPCMapMu.Lock()
	connPCMap[connKey] = peerConnection
	connPCMapMu.Unlock()

	// Ensure cleanup on disconnect.
	defer func() {
		connPCMapMu.Lock()
		delete(connPCMap, connKey)
		connPCMapMu.Unlock()
		peerConnection.Close()
	}()

	log.Info("New SSH connection from", connKey)

	// Discard global requests.
	go ssh.DiscardRequests(reqs)

	// Handle channels for this SSH connection.
	for newChannel := range chans {
		if newChannel.ChannelType() != "session" {
			newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
			continue
		}

		channel, requests, err := newChannel.Accept()
		if err != nil {
			log.Warn("Error accepting channel:", err)
			continue
		}

		// Process requests for this channel.
		go func(in <-chan *ssh.Request) {
			for req := range in {
				if req.Type == "exec" {
					command, err := parseSSHExecCommand(req.Payload)
					if err != nil {
						log.Error("Failed to parse exec command:", err)
						req.Reply(false, nil)
						channel.Close()
						continue
					}

					log.Info("Received command:", command)

					if command == "webrtc-signal" {
						req.Reply(true, nil) // Acknowledge the request.
						// Use the per-connection PeerConnection for signaling.
						HandleWebRTCSignaling(channel, peerConnection)
					} else {
						req.Reply(false, nil)
						channel.Close()
					}
				} else {
					req.Reply(false, nil)
				}
			}
		}(requests)
	}
}

func HandleWebRTCSignaling(channel ssh.Channel, peerConnection *webrtc.PeerConnection) {
	defer channel.Close()

	// Create channel buffer
	buf := make([]byte, 4096)
	n, err := channel.Read(buf)
	if err != nil && err != io.EOF {
		log.Fatal("Error reading from signaling channel:", err)
		return
	}

	sdpOffer := string(buf[:n])
	log.Info("Received SDP offer:", sdpOffer)

	// Process the SDP offer and create an answer
	sdpAnswer := ProcessSDPOffer(sdpOffer, peerConnection)
	_, err = channel.Write([]byte(sdpAnswer))
	if err != nil {
		log.Fatal("Error writing SDP answer to channel:", err)
		return
	}	
		
	// Block indefinitely
	select {}
}


func parseSSHExecCommand(payload []byte) (string, error) {
	if len(payload) < 4 {
		return "", errors.New("payload too short")
	}

	// Create a reader over the payload.
	r := bytes.NewReader(payload)

	// Read the 4-byte length field.
	var length uint32
	if err := binary.Read(r, binary.BigEndian, &length); err != nil {
		return "", err
	}

	// Ensure there are enough bytes for the command.
	if uint32(len(payload))-4 < length {
		return "", errors.New("payload does not contain full command")
	}

	// Read the command string.
	cmdBytes := make([]byte, length)
	if _, err := io.ReadFull(r, cmdBytes); err != nil {
		return "", err
	}

	return string(cmdBytes), nil
}

func ProcessSDPOffer(sdpOffer string, peerConnection *webrtc.PeerConnection) string {
	// Set the remote description
	err := peerConnection.SetRemoteDescription(webrtc.SessionDescription{
		Type: webrtc.SDPTypeOffer,
		SDP:  sdpOffer,
	})

	if err != nil {
		log.Fatal("Error setting remote description:", err)
		return ""
	}

	// Create an answer
	answer, err := peerConnection.CreateAnswer(nil)
	if err != nil {
		log.Fatal("Error creating answer:", err)
		return ""
	}
	
	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	// Set the local description
	err = peerConnection.SetLocalDescription(answer)
	if err != nil {
		log.Fatal("Error setting local description:", err)
		return ""
	}

	// Block until ICE gathering has completed
	<-gatherComplete

	return answer.SDP
}

func WriteOutgoingTrack(peerConnection *webrtc.PeerConnection, track *webrtc.TrackLocalStaticRTP) {
	client := &gortsplib.Client{}
	// Create a gortsplib client to read from the RTSP server. 
	u, err := base.ParseURL("rtsp://127.0.0.1:1234/")
	if err != nil {
		log.Fatal("Error parsing RTSP URL:", err)
	}
	
	err = client.Start(u.Scheme, u.Host)
	if err != nil {
		log.Fatal("Error starting RTSP client:", err)
	}

	desc, _, err := client.Describe(u)
	if err != nil {
		log.Fatal("Error describing RTSP stream:", err)
	}

	err = client.SetupAll(desc.BaseURL, desc.Medias)
	if err != nil {
		log.Fatal("Error setting up RTSP stream:", err)
	}

	client.OnPacketRTPAny(func(medi *description.Media, forma format.Format, pkt *rtp.Packet) {
		// Send packet to the WebRTC track.
		log.Info("Received RTP packet")
		if err := track.WriteRTP(pkt); err != nil {
			log.Fatal("Error writing RTP packet to track:", err)
		}
	})

	client.OnPacketRTCPAny(func(medi *description.Media, pkt rtcp.Packet) {
		log.Info("Received RTCP packet")
	})

	select {}
}

func HandleIncomingTrack(track *webrtc.TrackRemote, data chan []byte) {
	// receive rtp packets, use gocv to write to camera feed
	for {
		rtp, _, err := track.ReadRTP()
		if err != nil {
			log.Error("Error reading RTP packet:", err)
			break
		}

		// send rtp to channel
		data <- rtp.Payload
	}
}

func WriteToCamera(data chan []byte) {
    virtualCam, err := gocv.VideoWriterFile("/dev/video0", "MJPG", 60, 1920, 1080, true)
    if err != nil {
        log.Fatal("Error opening virtual camera:", err)
    }
    defer virtualCam.Close()
    
    var img gocv.Mat
    for imgBytes := range data {
        newImg, err := gocv.IMDecode(imgBytes, gocv.IMReadColor)
        if err != nil {
            log.Error("Error decoding image bytes:", err)
            continue
        }
        // Close previous Mat if it was allocated
        if !img.Empty() {
            img.Close()
        }
        img = newImg
        virtualCam.Write(img)
    }
    // Final cleanup
    if !img.Empty() {
        img.Close()
    }
}
