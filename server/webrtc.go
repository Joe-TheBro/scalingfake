package main

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"sync"

	"github.com/bluenviron/gortsplib/v4/pkg/sdp"
	"github.com/charmbracelet/log"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/rtp"
	"github.com/pion/webrtc/v4"
	"gocv.io/x/gocv"
	"golang.org/x/crypto/ssh"
)

// global map and mutex for handling tracking connections
var (
	connPCMap = make(map[string]*webrtc.PeerConnection)
	connPCMapMu sync.Mutex
)

func CreatePeerConnection() (*webrtc.PeerConnection, error) {
	mediaEngine := &webrtc.MediaEngine{}

	webrtcConfig := webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}

	

	if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: "video/H264", ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
	},
		webrtc.RTPCodecTypeVideo); err != nil {
		log.Error("Failed to register H264 codec:", err)
		return nil, err
	}

	// if err := mediaEngine.RegisterCodec(webrtc.RTPCodecParameters{
	// 	RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: "video/H264", ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
	// },
	// 	webrtc.RTPCodecTypeAudio); err != nil {
	// 	log.Error("Failed to register H264 codec:", err)
	// 	return nil, err
	// }

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	intercepterRegistry := &interceptor.Registry{}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		log.Error("Failed to create intervalpli interceptor:", err)
		return nil, err
	}
	intercepterRegistry.Add(intervalPliFactory)

	if err = webrtc.RegisterDefaultInterceptors(mediaEngine, intercepterRegistry); err != nil {
		log.Error("Failed to register default interceptors:", err)
		return nil, err
	}

	api := webrtc.NewAPI(webrtc.WithMediaEngine(mediaEngine), webrtc.WithInterceptorRegistry(intercepterRegistry))
	return api.NewPeerConnection(webrtcConfig)
}

func StartSshSignalingServer(privateBytes []byte) {
	privateKey, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		log.Fatal("Error parsing private key:", err)
	}

	sshConfig := &ssh.ServerConfig{
		NoClientAuth: false,
		PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
			return nil, nil
		},
	}

	sshConfig.AddHostKey(privateKey)

	// Listen for incoming connections
	listener, err := net.Listen("tcp", "0.0.0.0:2222")
	if err != nil {
		log.Fatal("Error listening on port 2222:", err)
	}
	log.Info("Signaling server listening on port 2222")

	for {
		tcpConn, err := listener.Accept()
		if err != nil {
			log.Warn("Error accepting connection:", err)
			continue
		}

		go handleSSHConnection(tcpConn, sshConfig)		
	}
}

func handleSSHConnection(conn net.Conn, sshConfig *ssh.ServerConfig) {
	sshConn, chans, reqs, err := ssh.NewServerConn(conn, sshConfig)
	if err != nil {
		log.Warn("SSH handshake failed:", err)
		conn.Close()
		return
	}
	defer sshConn.Close()

	// Create a new PeerConnection for this SSH connection.
	peerConnection, err := CreatePeerConnection()
	if err != nil {
		log.Error("Failed to create PeerConnection:", err)
		return
	}
	defer func() {
		if err := peerConnection.Close(); err != nil {
			log.Error("Failed to close PeerConnection:", err)
		}
	}()

	// Set the handler for ICE connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnICEConnectionStateChange(func(connectionState webrtc.ICEConnectionState) {
		log.Printf("Connection State has changed %s \n", connectionState.String())
	})

	// incoming tracks
	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
		data := make(chan []byte)
		go HandleIncomingTrack(track, data)
		go WriteToCamera(data)
	})

	// Add outgoing track
	track, err := webrtc.NewTrackLocalStaticRTP(webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeH264}, "video", "pion")
	if err != nil {
		log.Error("Failed to create outgoing track:", err)
		return
	}
	go WriteOutgoingTrack(peerConnection, track)

	// Store the mapping using the remote address as a key.
	connKey := sshConn.RemoteAddr().String()
	connPCMapMu.Lock()
	connPCMap[connKey] = peerConnection
	connPCMapMu.Unlock()

	// Ensure cleanup on disconnect.
	defer func() {
		connPCMapMu.Lock()
		delete(connPCMap, connKey)
		connPCMapMu.Unlock()
		peerConnection.Close()
	}()

	log.Info("New SSH connection from", connKey)

	// Discard global requests.
	go ssh.DiscardRequests(reqs)

	// Handle channels for this SSH connection.
	for newChannel := range chans {
		if newChannel.ChannelType() != "session" {
			newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
			continue
		}

		channel, requests, err := newChannel.Accept()
		if err != nil {
			log.Warn("Error accepting channel:", err)
			continue
		}

		// Process requests for this channel.
		go func(in <-chan *ssh.Request) {
			for req := range in {
				if req.Type == "exec" {
					command, err := parseSSHExecCommand(req.Payload)
					if err != nil {
						log.Error("Failed to parse exec command:", err)
						req.Reply(false, nil)
						channel.Close()
						continue
					}

					log.Info("Received command:", command)

					if command == "webrtc-signal" {
						req.Reply(true, nil) // Acknowledge the request.
						// Use the per-connection PeerConnection for signaling.
						HandleWebRTCSignaling(channel, peerConnection)
					} else {
						req.Reply(false, nil)
						channel.Close()
					}
				} else {
					req.Reply(false, nil)
				}
			}
		}(requests)
	}
}

func HandleWebRTCSignaling(channel ssh.Channel, peerConnection *webrtc.PeerConnection) {
	defer channel.Close()

	// Create channel buffer
	buf := make([]byte, 4096)
	n, err := channel.Read(buf)
	if err != nil && err != io.EOF {
		log.Fatal("Error reading from signaling channel:", err)
		return
	}

	sdpOffer := string(buf[:n])
	log.Info("Received SDP offer:", sdpOffer)

	// Process the SDP offer and create an answer
	sdpAnswer := ProcessSDPOffer(sdpOffer, peerConnection)
	_, err = channel.Write([]byte(sdpAnswer))
	if err != nil {
		log.Fatal("Error writing SDP answer to channel:", err)
		return
	}	
		
	// Block indefinitely
	select {}
}


func parseSSHExecCommand(payload []byte) (string, error) {
	if len(payload) < 4 {
		return "", errors.New("payload too short")
	}

	// Create a reader over the payload.
	r := bytes.NewReader(payload)

	// Read the 4-byte length field.
	var length uint32
	if err := binary.Read(r, binary.BigEndian, &length); err != nil {
		return "", err
	}

	// Ensure there are enough bytes for the command.
	if uint32(len(payload))-4 < length {
		return "", errors.New("payload does not contain full command")
	}

	// Read the command string.
	cmdBytes := make([]byte, length)
	if _, err := io.ReadFull(r, cmdBytes); err != nil {
		return "", err
	}

	return string(cmdBytes), nil
}

func ProcessSDPOffer(sdpOffer string, peerConnection *webrtc.PeerConnection) string {
	// Set the remote description
	err := peerConnection.SetRemoteDescription(webrtc.SessionDescription{
		Type: webrtc.SDPTypeOffer,
		SDP:  sdpOffer,
	})

	if err != nil {
		log.Fatal("Error setting remote description:", err)
		return ""
	}

	// Create an answer
	answer, err := peerConnection.CreateAnswer(nil)
	if err != nil {
		log.Fatal("Error creating answer:", err)
		return ""
	}
	
	gatherComplete := webrtc.GatheringCompletePromise(peerConnection)

	// Set the local description
	err = peerConnection.SetLocalDescription(answer)
	if err != nil {
		log.Fatal("Error setting local description:", err)
		return ""
	}

	// Block until ICE gathering has completed
	<-gatherComplete

	return answer.SDP
}

func WriteOutgoingTrack(peerConnection *webrtc.PeerConnection, track *webrtc.TrackLocalStaticRTP) {
	// Read the SDP file that describes the RTP stream
	sdpBytes, err := os.ReadFile("./data/output.sdp")
	if err != nil {
		log.Fatal("Error reading SDP file:", err)
	}

	// Parse the SDP file
	sdpString := string(sdpBytes)
	if sdpString == "" {
		log.Fatal("SDP file is empty")
	}

	// Remove the first line of the SDP file
	// sdpString = strings.Split(sdpString, "\n")[1]
	sdpBytes = []byte(sdpString)

	var session sdp.SessionDescription
	if err := session.Unmarshal(sdpBytes); err != nil {
		log.Fatal("Error unmarshalling SDP:", err)
	}

	var listenIP string
	var listenPort int

	if session.ConnectionInformation != nil && session.ConnectionInformation.Address != nil {
		listenIP = session.ConnectionInformation.Address.Address
	}

	for _, md := range session.MediaDescriptions {
		if md.MediaName.Media == "video" {
			if md.ConnectionInformation != nil && md.ConnectionInformation.Address != nil {
				listenIP = md.ConnectionInformation.Address.Address
			}
			listenPort = md.MediaName.Port.Value
			break
		}
	}

	if listenIP == "" {
		// fallback for no c value
		listenIP = "0.0.0.0"
	}
	if listenPort == 0 {
		log.Fatal("No video port found in SDP")
	}

	listenAddr := fmt.Sprintf("%s:%d", listenIP, listenPort)
	udpConn, err := net.ListenPacket("udp", listenAddr)
	if err != nil {
		log.Fatal("Error listening on UDP:", err)
	}
	defer udpConn.Close()

	log.Info("Listening for incoming RTP packets on", listenAddr)

	go func() {
		buf := make([]byte, 1500) // UDP MTU
		for {
			n, _, err := udpConn.ReadFrom(buf)
			if err != nil {
				log.Error("Error reading from UDP:", err)
				return
			}

			var pkt rtp.Packet
			if err := pkt.Unmarshal(buf[:n]); err != nil {
				log.Error("Error unmarshalling RTP packet:", err)
				continue
			}

			if err := track.WriteRTP(&pkt); err != nil {
				log.Error("Error writing RTP packet:", err)
			}
		}
	}()

	// Block indefinitely
	select {}
}

func HandleIncomingTrack(track *webrtc.TrackRemote, data chan []byte) {
	// receive rtp packets, use gocv to write to camera feed
	for {
		rtp, _, err := track.ReadRTP()
		if err != nil {
			log.Error("Error reading RTP packet:", err)
			break
		}

		// send rtp to channel
		data <- rtp.Payload
	}
}

func WriteToCamera(data chan []byte) {
    virtualCam, err := gocv.VideoWriterFile("/dev/video0", "MJPG", 60, 1920, 1080, true)
    if err != nil {
        log.Fatal("Error opening virtual camera:", err)
    }
    defer virtualCam.Close()
    
    var img gocv.Mat
    for imgBytes := range data {
        newImg, err := gocv.IMDecode(imgBytes, gocv.IMReadColor)
        if err != nil {
            log.Error("Error decoding image bytes:", err)
            continue
        }
        // Close previous Mat if it was allocated
        if !img.Empty() {
            img.Close()
        }
        img = newImg
        virtualCam.Write(img)
    }
    // Final cleanup
    if !img.Empty() {
        img.Close()
    }
}
